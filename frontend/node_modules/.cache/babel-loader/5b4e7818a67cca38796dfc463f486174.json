{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar baseX$1 = require('../../vendor/base-x.js');\nvar bytes = require('../bytes.js');\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n}\nconst or = (left, right) => new ComposedDecoder({\n  ...(left.decoders || {\n    [left.prefix]: left\n  }),\n  ...(right.decoders || {\n    [right.prefix]: right\n  })\n});\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nconst from = ({\n  name,\n  prefix,\n  encode,\n  decode\n}) => new Codec(name, prefix, encode, decode);\nconst baseX = ({\n  prefix,\n  name,\n  alphabet\n}) => {\n  const {\n    encode,\n    decode\n  } = baseX$1(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => bytes.coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nconst rfc4648 = ({\n  name,\n  prefix,\n  bitsPerChar,\n  alphabet\n}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = or;\nexports.rfc4648 = rfc4648;","map":{"version":3,"names":["Object","defineProperty","exports","value","baseX$1","require","bytes","Encoder","constructor","name","prefix","baseEncode","encode","Uint8Array","Error","Decoder","baseDecode","codePointAt","undefined","prefixCodePoint","decode","text","JSON","stringify","slice","length","or","decoder","ComposedDecoder","decoders","input","RangeError","keys","left","right","Codec","encoder","from","baseX","alphabet","coerce","string","bitsPerChar","codes","i","end","out","bits","buffer","written","SyntaxError","data","pad","mask","rfc4648"],"sources":["C:/Users/Administrator/Downloads/blockchain-bookstore/frontend/node_modules/multiformats/cjs/src/bases/base.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar baseX$1 = require('../../vendor/base-x.js');\nvar bytes = require('../bytes.js');\n\nclass Encoder {\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${ this.prefix }${ this.baseEncode(bytes) }`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\nclass Decoder {\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefix.codePointAt(0);\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${ JSON.stringify(text) }, ${ this.name } decoder only supports inputs prefixed with ${ this.prefix }`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${ JSON.stringify(input) }, only inputs prefixed with ${ Object.keys(this.decoders) } are supported`);\n    }\n  }\n}\nconst or = (left, right) => new ComposedDecoder({\n  ...left.decoders || { [left.prefix]: left },\n  ...right.decoders || { [right.prefix]: right }\n});\nclass Codec {\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nconst from = ({name, prefix, encode, decode}) => new Codec(name, prefix, encode, decode);\nconst baseX = ({prefix, name, alphabet}) => {\n  const {encode, decode} = baseX$1(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => bytes.coerce(decode(text))\n  });\n};\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  const codes = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i;\n  }\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  let bits = 0;\n  let buffer = 0;\n  let written = 0;\n  for (let i = 0; i < end; ++i) {\n    const value = codes[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${ name } character`);\n    }\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 255 & buffer >> bits;\n    }\n  }\n  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n};\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0;\n  let buffer = 0;\n  for (let i = 0; i < data.length; ++i) {\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  if (bits) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  if (pad) {\n    while (out.length * bitsPerChar & 7) {\n      out += '=';\n    }\n  }\n  return out;\n};\nconst rfc4648 = ({name, prefix, bitsPerChar, alphabet}) => {\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabet, bitsPerChar, name);\n    }\n  });\n};\n\nexports.Codec = Codec;\nexports.baseX = baseX;\nexports.from = from;\nexports.or = or;\nexports.rfc4648 = rfc4648;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}