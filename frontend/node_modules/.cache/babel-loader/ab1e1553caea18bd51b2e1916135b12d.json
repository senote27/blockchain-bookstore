{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar errcode = require('err-code');\nvar unixfs = require('./unixfs.js');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);\nconst PBData = unixfs.Data;\nconst types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nconst dirTypes = ['directory', 'hamt-sharded-directory'];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n  if (typeof mode === 'number') {\n    return mode & 4095;\n  }\n  mode = mode.toString();\n  if (mode.substring(0, 1) === '0') {\n    return parseInt(mode, 8) & 4095;\n  }\n  return parseInt(mode, 10) & 4095;\n}\nfunction parseMtime(input) {\n  if (input == null) {\n    return undefined;\n  }\n  let mtime;\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    };\n  }\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    };\n  }\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    };\n  }\n  if (input instanceof Date) {\n    const ms = input.getTime();\n    const secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode__default[\"default\"](new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n  return mtime;\n}\nclass UnixFS {\n  static unmarshal(marshaled) {\n    const message = PBData.decode(marshaled);\n    const decoded = PBData.toObject(message, {\n      defaults: false,\n      arrays: true,\n      longs: Number,\n      objects: false\n    });\n    const data = new UnixFS({\n      type: types[decoded.Type],\n      data: decoded.Data,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.mode,\n      mtime: decoded.mtime ? {\n        secs: decoded.mtime.Seconds,\n        nsecs: decoded.mtime.FractionalNanoseconds\n      } : undefined\n    });\n    data._originalMode = decoded.mode || 0;\n    return data;\n  }\n  constructor(options = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options;\n    if (type && !types.includes(type)) {\n      throw errcode__default[\"default\"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    this.type = type || 'file';\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    this.blockSizes = blockSizes || [];\n    this._originalMode = 0;\n    this.mode = parseMode(mode);\n    if (mtime) {\n      this.mtime = parseMtime(mtime);\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0;\n      }\n    }\n  }\n  set mode(mode) {\n    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n    const parsedMode = parseMode(mode);\n    if (parsedMode !== undefined) {\n      this._mode = parsedMode;\n    }\n  }\n  get mode() {\n    return this._mode;\n  }\n  isDirectory() {\n    return Boolean(this.type && dirTypes.includes(this.type));\n  }\n  addBlockSize(size) {\n    this.blockSizes.push(size);\n  }\n  removeBlockSize(index) {\n    this.blockSizes.splice(index, 1);\n  }\n  fileSize() {\n    if (this.isDirectory()) {\n      return 0;\n    }\n    let sum = 0;\n    this.blockSizes.forEach(size => {\n      sum += size;\n    });\n    if (this.data) {\n      sum += this.data.length;\n    }\n    return sum;\n  }\n  marshal() {\n    let type;\n    switch (this.type) {\n      case 'raw':\n        type = PBData.DataType.Raw;\n        break;\n      case 'directory':\n        type = PBData.DataType.Directory;\n        break;\n      case 'file':\n        type = PBData.DataType.File;\n        break;\n      case 'metadata':\n        type = PBData.DataType.Metadata;\n        break;\n      case 'symlink':\n        type = PBData.DataType.Symlink;\n        break;\n      case 'hamt-sharded-directory':\n        type = PBData.DataType.HAMTShard;\n        break;\n      default:\n        throw errcode__default[\"default\"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    let data = this.data;\n    if (!this.data || !this.data.length) {\n      data = undefined;\n    }\n    let mode;\n    if (this.mode != null) {\n      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined;\n      }\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined;\n      }\n    }\n    let mtime;\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime);\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        };\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds;\n        }\n      }\n    }\n    const pbData = {\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    };\n    return PBData.encode(pbData).finish();\n  }\n}\nexports.UnixFS = UnixFS;\nexports.parseMode = parseMode;\nexports.parseMtime = parseMtime;","map":{"version":3,"names":["Object","defineProperty","exports","value","errcode","require","unixfs","_interopDefaultLegacy","e","errcode__default","PBData","Data","types","dirTypes","DEFAULT_FILE_MODE","parseInt","DEFAULT_DIRECTORY_MODE","parseMode","mode","undefined","toString","substring","parseMtime","input","mtime","secs","nsecs","Seconds","FractionalNanoseconds","Array","isArray","Date","ms","getTime","Math","floor","prototype","hasOwnProperty","call","Error","UnixFS","unmarshal","marshaled","message","decode","decoded","toObject","defaults","arrays","longs","Number","objects","data","type","Type","blockSizes","blocksizes","_originalMode","constructor","options","hashType","fanout","includes","_mode","isDirectory","parsedMode","Boolean","addBlockSize","size","push","removeBlockSize","index","splice","fileSize","sum","forEach","length","marshal","DataType","Raw","Directory","File","Metadata","Symlink","HAMTShard","parsed","pbData","filesize","encode","finish"],"sources":["C:/Users/Administrator/Downloads/blockchain-bookstore/frontend/node_modules/ipfs-unixfs/cjs/src/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar errcode = require('err-code');\nvar unixfs = require('./unixfs.js');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);\n\nconst PBData = unixfs.Data;\nconst types = [\n  'raw',\n  'directory',\n  'file',\n  'metadata',\n  'symlink',\n  'hamt-sharded-directory'\n];\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n];\nconst DEFAULT_FILE_MODE = parseInt('0644', 8);\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n  if (typeof mode === 'number') {\n    return mode & 4095;\n  }\n  mode = mode.toString();\n  if (mode.substring(0, 1) === '0') {\n    return parseInt(mode, 8) & 4095;\n  }\n  return parseInt(mode, 10) & 4095;\n}\nfunction parseMtime(input) {\n  if (input == null) {\n    return undefined;\n  }\n  let mtime;\n  if (input.secs != null) {\n    mtime = {\n      secs: input.secs,\n      nsecs: input.nsecs\n    };\n  }\n  if (input.Seconds != null) {\n    mtime = {\n      secs: input.Seconds,\n      nsecs: input.FractionalNanoseconds\n    };\n  }\n  if (Array.isArray(input)) {\n    mtime = {\n      secs: input[0],\n      nsecs: input[1]\n    };\n  }\n  if (input instanceof Date) {\n    const ms = input.getTime();\n    const secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {\n    throw errcode__default[\"default\"](new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n  return mtime;\n}\nclass UnixFS {\n  static unmarshal(marshaled) {\n    const message = PBData.decode(marshaled);\n    const decoded = PBData.toObject(message, {\n      defaults: false,\n      arrays: true,\n      longs: Number,\n      objects: false\n    });\n    const data = new UnixFS({\n      type: types[decoded.Type],\n      data: decoded.Data,\n      blockSizes: decoded.blocksizes,\n      mode: decoded.mode,\n      mtime: decoded.mtime ? {\n        secs: decoded.mtime.Seconds,\n        nsecs: decoded.mtime.FractionalNanoseconds\n      } : undefined\n    });\n    data._originalMode = decoded.mode || 0;\n    return data;\n  }\n  constructor(options = { type: 'file' }) {\n    const {type, data, blockSizes, hashType, fanout, mtime, mode} = options;\n    if (type && !types.includes(type)) {\n      throw errcode__default[\"default\"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    this.type = type || 'file';\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    this.blockSizes = blockSizes || [];\n    this._originalMode = 0;\n    this.mode = parseMode(mode);\n    if (mtime) {\n      this.mtime = parseMtime(mtime);\n      if (this.mtime && !this.mtime.nsecs) {\n        this.mtime.nsecs = 0;\n      }\n    }\n  }\n  set mode(mode) {\n    this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;\n    const parsedMode = parseMode(mode);\n    if (parsedMode !== undefined) {\n      this._mode = parsedMode;\n    }\n  }\n  get mode() {\n    return this._mode;\n  }\n  isDirectory() {\n    return Boolean(this.type && dirTypes.includes(this.type));\n  }\n  addBlockSize(size) {\n    this.blockSizes.push(size);\n  }\n  removeBlockSize(index) {\n    this.blockSizes.splice(index, 1);\n  }\n  fileSize() {\n    if (this.isDirectory()) {\n      return 0;\n    }\n    let sum = 0;\n    this.blockSizes.forEach(size => {\n      sum += size;\n    });\n    if (this.data) {\n      sum += this.data.length;\n    }\n    return sum;\n  }\n  marshal() {\n    let type;\n    switch (this.type) {\n    case 'raw':\n      type = PBData.DataType.Raw;\n      break;\n    case 'directory':\n      type = PBData.DataType.Directory;\n      break;\n    case 'file':\n      type = PBData.DataType.File;\n      break;\n    case 'metadata':\n      type = PBData.DataType.Metadata;\n      break;\n    case 'symlink':\n      type = PBData.DataType.Symlink;\n      break;\n    case 'hamt-sharded-directory':\n      type = PBData.DataType.HAMTShard;\n      break;\n    default:\n      throw errcode__default[\"default\"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n    let data = this.data;\n    if (!this.data || !this.data.length) {\n      data = undefined;\n    }\n    let mode;\n    if (this.mode != null) {\n      mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined;\n      }\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined;\n      }\n    }\n    let mtime;\n    if (this.mtime != null) {\n      const parsed = parseMtime(this.mtime);\n      if (parsed) {\n        mtime = {\n          Seconds: parsed.secs,\n          FractionalNanoseconds: parsed.nsecs\n        };\n        if (mtime.FractionalNanoseconds === 0) {\n          delete mtime.FractionalNanoseconds;\n        }\n      }\n    }\n    const pbData = {\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    };\n    return PBData.encode(pbData).finish();\n  }\n}\n\nexports.UnixFS = UnixFS;\nexports.parseMode = parseMode;\nexports.parseMtime = parseMtime;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}