{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar is = require('./is.js');\nvar token = require('./token.js');\nvar bl = require('./bl.js');\nvar common = require('./common.js');\nvar jump = require('./jump.js');\nvar byteUtils = require('./byte-utils.js');\nvar _0uint = require('./0uint.js');\nvar _1negint = require('./1negint.js');\nvar _2bytes = require('./2bytes.js');\nvar _3string = require('./3string.js');\nvar _4array = require('./4array.js');\nvar _5map = require('./5map.js');\nvar _6tag = require('./6tag.js');\nvar _7float = require('./7float.js');\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nfunction makeCborEncoders() {\n  const encoders = [];\n  encoders[token.Type.uint.major] = _0uint.encodeUint;\n  encoders[token.Type.negint.major] = _1negint.encodeNegint;\n  encoders[token.Type.bytes.major] = _2bytes.encodeBytes;\n  encoders[token.Type.string.major] = _3string.encodeString;\n  encoders[token.Type.array.major] = _4array.encodeArray;\n  encoders[token.Type.map.major] = _5map.encodeMap;\n  encoders[token.Type.tag.major] = _6tag.encodeTag;\n  encoders[token.Type.float.major] = _7float.encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new bl.Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${common.encodeErrPrefix} object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new token.Token(token.Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.array, obj.length), entries, new token.Token(token.Type.break)];\n    }\n    return [new token.Token(token.Type.array, obj.length), entries];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new token.Token(token.Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new token.Token(token.Type.map, length), entries, new token.Token(token.Type.break)];\n    }\n    return [new token.Token(token.Type.map, length), entries];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${common.encodeErrPrefix} unsupported type: ${typ}`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);\n      }\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.makeCborEncoders = makeCborEncoders;\nexports.objectToTokens = objectToTokens;","map":{"version":3,"names":["Object","defineProperty","exports","value","is","require","token","bl","common","jump","byteUtils","_0uint","_1negint","_2bytes","_3string","_4array","_5map","_6tag","_7float","defaultEncodeOptions","float64","mapSorter","quickEncodeToken","makeCborEncoders","encoders","Type","uint","major","encodeUint","negint","encodeNegint","bytes","encodeBytes","string","encodeString","array","encodeArray","map","encodeMap","tag","encodeTag","float","encodeFloat","cborEncoders","buf","Bl","Ref","constructor","obj","parent","includes","p","createCheck","stack","Error","encodeErrPrefix","simpleTokens","null","Token","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","entries","i","e","objectToTokens","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","asU8A","reset","toBytes","encode","assign"],"sources":["C:/Users/Administrator/Downloads/blockchain-bookstore/frontend/node_modules/cborg/cjs/lib/encode.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar is = require('./is.js');\nvar token = require('./token.js');\nvar bl = require('./bl.js');\nvar common = require('./common.js');\nvar jump = require('./jump.js');\nvar byteUtils = require('./byte-utils.js');\nvar _0uint = require('./0uint.js');\nvar _1negint = require('./1negint.js');\nvar _2bytes = require('./2bytes.js');\nvar _3string = require('./3string.js');\nvar _4array = require('./4array.js');\nvar _5map = require('./5map.js');\nvar _6tag = require('./6tag.js');\nvar _7float = require('./7float.js');\n\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken: jump.quickEncodeToken\n};\nfunction makeCborEncoders() {\n  const encoders = [];\n  encoders[token.Type.uint.major] = _0uint.encodeUint;\n  encoders[token.Type.negint.major] = _1negint.encodeNegint;\n  encoders[token.Type.bytes.major] = _2bytes.encodeBytes;\n  encoders[token.Type.string.major] = _3string.encodeString;\n  encoders[token.Type.array.major] = _4array.encodeArray;\n  encoders[token.Type.map.major] = _5map.encodeMap;\n  encoders[token.Type.tag.major] = _6tag.encodeTag;\n  encoders[token.Type.float.major] = _7float.encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new bl.Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ common.encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new token.Token(token.Type.null, null),\n  undefined: new token.Token(token.Type.undefined, undefined),\n  true: new token.Token(token.Type.true, true),\n  false: new token.Token(token.Type.false, false),\n  emptyArray: new token.Token(token.Type.array, 0),\n  emptyMap: new token.Token(token.Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new token.Token(token.Type.float, obj);\n    } else if (obj >= 0) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new token.Token(token.Type.uint, obj);\n    } else {\n      return new token.Token(token.Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new token.Token(token.Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.array, obj.length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new token.Token(token.Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new token.Token(token.Type.map, length),\n        entries,\n        new token.Token(token.Type.break)\n      ];\n    }\n    return [\n      new token.Token(token.Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is.is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ common.encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new bl.Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return byteUtils.asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\n\nexports.Ref = Ref;\nexports.encode = encode;\nexports.encodeCustom = encodeCustom;\nexports.makeCborEncoders = makeCborEncoders;\nexports.objectToTokens = objectToTokens;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}