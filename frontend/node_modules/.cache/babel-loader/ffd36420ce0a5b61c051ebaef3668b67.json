{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar token = require('../token.js');\nvar encode$1 = require('../encode.js');\nvar common = require('../common.js');\nvar byteUtils = require('../byte-utils.js');\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === token.Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === token.Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [token.Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [token.Type.negint.major](buf, token$1) {\n    this[token.Type.uint.major](buf, token$1);\n  }\n  [token.Type.bytes.major](_buf, _token) {\n    throw new Error(`${common.encodeErrPrefix} unsupported type: Uint8Array`);\n  }\n  [token.Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = byteUtils.fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? byteUtils.asU8A(byts) : byts);\n  }\n  [token.Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [token.Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [token.Type.tag.major](_buf, _token) {}\n  [token.Type.float.major](buf, token$1) {\n    if (token$1.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === token.Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === token.Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token$1.value === undefined) {\n      throw new Error(`${common.encodeErrPrefix} unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token$1.type.name === 'true') {\n      buf.push([116, 114, 117, 101]);\n      return;\n    } else if (token$1.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]);\n      return;\n    } else if (token$1.type.name === 'null') {\n      buf.push([110, 117, 108, 108]);\n      return;\n    }\n    const is = String(token$1.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${common.encodeErrPrefix} complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== token.Type.string || keyToken2.type !== token.Type.string) {\n    throw new Error(`${common.encodeErrPrefix} non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${common.encodeErrPrefix} unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encode$1.encodeCustom(data, new JSONEncoder(), options);\n}\nexports.encode = encode;","map":{"version":3,"names":["Object","defineProperty","exports","value","token","require","encode$1","common","byteUtils","JSONEncoder","Array","constructor","inRecursive","prefix","buf","recurs","length","type","Type","array","elements","push","map","uint","major","is","String","isa","i","charCodeAt","negint","token$1","bytes","_buf","_token","Error","encodeErrPrefix","string","byts","fromString","JSON","stringify","asU8A","tag","float","name","pop","undefined","dp","mapSorter","e1","e2","isArray","keyToken1","keyToken2","defaultEncodeOptions","addBreakTokens","encode","data","options","assign","encodeCustom"],"sources":["C:/Users/Administrator/Downloads/blockchain-bookstore/frontend/node_modules/cborg/cjs/lib/json/encode.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar token = require('../token.js');\nvar encode$1 = require('../encode.js');\nvar common = require('../common.js');\nvar byteUtils = require('../byte-utils.js');\n\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === token.Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === token.Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [token.Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [token.Type.negint.major](buf, token$1) {\n    this[token.Type.uint.major](buf, token$1);\n  }\n  [token.Type.bytes.major](_buf, _token) {\n    throw new Error(`${ common.encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [token.Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = byteUtils.fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? byteUtils.asU8A(byts) : byts);\n  }\n  [token.Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [token.Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: token.Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [token.Type.tag.major](_buf, _token) {\n  }\n  [token.Type.float.major](buf, token$1) {\n    if (token$1.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === token.Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === token.Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token$1.value === undefined) {\n      throw new Error(`${ common.encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token$1.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token$1.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token$1.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token$1.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ common.encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== token.Type.string || keyToken2.type !== token.Type.string) {\n    throw new Error(`${ common.encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ common.encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encode$1.encodeCustom(data, new JSONEncoder(), options);\n}\n\nexports.encode = encode;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}